#3a) (2p)
#Generate a vector containing even numbers from 2 to 50 inclusive (Hint! ?seq)
#Build a 5x5 matrix and populate it with the vector generated above, where matrix
#elements are increasing by row. Finally check whether R stored it as a matrix.
# ?seq
even <- seq(2, 50, by=2) # used increment of 2 to get even numbers starting from 2
even
evenM1 <- matrix(even, nrow = 5, ncol = 5, byrow = FALSE) # by column
evenM1
evenM2 <- matrix(even, nrow = 5, ncol = 5, byrow = TRUE) # by row
evenM2
typeof(evenM1)
#3b) (1p)
#Print the element for which Row=3 Column=4. Make the diagonal elements of the matrix 0 (Hint! ?diag)
#4a) (1p)
#Load the "SportsAnalytics270" library, load the dataset "nba2009_2016"
#from it and save it in R with the name "nba".
#4b) (2p)
#check the structure of the "nba" database and answer the following questions.
#*) What is the number of rows and columns ?
#*) What are the datatypes of columns "home.PTS", "home.WL" and "home.TEAM_NAME"
#5) (3p)
#Subset the dataframe "nba" into "nba_matches" which will store only home.TEAM_NAME, home.PTS,
#away.TEAM_NAME and away.PTS. Do the same by using column indexes and column names.
#6) (3p)
#Subset the "nba" dataframe into "nba_1" containing onyl those games, where the
#minimum difference between points is 5. (Hint! ?abs)
#7) (4p)
#Write a function that takes "x" as an argument and returns vector "y" containing all
#the divisors of "x". (Hint! x%%y expression shows the remainder when x is divided by y)
#8) (3p)
#Use for loop statement to populate a 5x5 square matrix with random numbers from
#the interval 1-10. (Hint! ?sample).
#9) (5p)
#Write a function that takes "x" vector as an input and returns it in an increasing order.
#(Warning!!! Don't use any built in sorting function in R or from other libraries)
#(Hint! There are many sorting algorithms used to sort a vector, an array etc. One is bubblesort)
# https://en.wikipedia.org/wiki/Bubble_sort
#10) (3p)
# Load Exams dataset from Moodle, explain in what format (wide, long) it's represented
#and convert vice versa(If it is wide, convert to long and if long, convert to wide.)
evenM1
evenM2
typeof(evenM1)
typeof(evenM1)
typeof(evenM2)
evenM2[3, 4]
evenM2
evenM2[3, 4]
## ?diag
?diag
diag(evenM2) <- 0
evenM2
library(devtools)
install.packages(devtools)
install.packages("devtools")
library(devtools)
install_github("HABET/CSE270")
library(SportsAnalytics270)
nba <- data("nba2009_2016")
data("nba2009_2016")
str(nba)
data("nba2009_2016")
# install_github("HABET/CSE270")
library(SportsAnalytics270)
data("nba2009_2016")
str(nba2009_2016)
nba <- data(nba2009_2016)
str(nba)
nba <- nba2009_2016
#data("nba2009_2016")
nba <- data("nba2009_2016")
str(nba)
data("nba2009_2016")
# install_github("HABET/CSE270")
library(SportsAnalytics270)
data("nba2009_2016")
data(nba2009_2016)
data(nba2009_2016)
# install_github("HABET/CSE270")
library(SportsAnalytics270)
data("nba2009_2016")
nba <- nba2009_2016
str(nba)
View(nba2009_2016)
typeof(nba[, "home.PTS"])
typeof(nba[, "home.WL"])
typeof(nba[, "home.TEAM_NAME"])
nba[, "home.TEAM_NAME"]
View(nba2009_2016)
typeof(nba[, "home.PTS"])
str(nba)
sapply(nba, typeof)
sapply(nba, class)
nba_matches <- nba[, "home.TEAM_NAME", "home.PTS", "away.TEAM_NAME", "away.PTS"]
nba_matches <- nba[, c("home.TEAM_NAME", "home.PTS", "away.TEAM_NAME", "away.PTS")]
nba_matches
View(nba_matches)
View(nba2009_2016)
nba_matches <- nba[, c(4, 5, 7, 8)]
nba_matches # same results for both
View(nba_matches)
## ?abs
?abs
nba_1 <- nba[, which(abs(nba$home.PTS -nba$away.PTS) >= 5)]
nba_1 <- subset(nba, abs(home.PTS - away.PTS) > 5 )
nba_1
View(nba_1)
nba_1 <- subset(nba, abs(home.PTS - away.PTS) = 5 )
nba_1 <- subset(nba, abs(home.PTS - away.PTS) == 5 )
nba_1 <- subset(nba, abs(home.PTS - away.PTS) >= 5 )
divisors <- function(x){
##  vector of potential numbers
y <- seq_len(x)
##  If the remainder is 0 => the number is a divisor of x
y[ x%%y == 0 ]
}
divisors <- function(x){
##  vector of potential numbers
y <- seq_len(x)
y
##  If the remainder is 0 => the number is a divisor of x
y[ x%%y == 0 ]
}
y
divisors(21)
return y
divisors(21)
##  If the remainder is 0 => the number is a divisor of x
return(y[ x%%y == 0 ])
divisors(21)
divisors(33)
?sample
class(evenM1)
even <- seq(2, 50, by=2) # used increment of 2 to get even numbers starting from 2
even
evenM1 <- matrix(even, nrow = 5, ncol = 5, byrow = FALSE) # by column
evenM1
evenM2 <- matrix(even, nrow = 5, ncol = 5, byrow = TRUE) # by row
evenM2
class(evenM1)
class(evenM2)
?sample
x <- 1:10
x <- seq(1, 10, by = 1)
randMat <- matrix(data = NA, nrow = 5, ncol = 5)
randMat
class(randMat)
for(j in 1:k){
for(i in 1:n){
x[i,j] = sample(x, 1)
}
}
for(i in 1:5){
x[i,j] = sample(x, 1)
}
randMat
x <- seq(1, 10, by = 1)
randMat <- matrix(data = NA, nrow = 5, ncol = 5)
randMat[i,j] = sample(x, 1)
for(j in 1:5){
for(i in 1:5){
randMat[i, j] = sample(x, 1)
}
}
randMat
## or the same with ine loop
for(j in 1:5){
randMat[i, j] = sample(x, 5) # sample from x with size 1
}
## or the same with ine loop
for(j in 1:5){
randMat[j] = sample(x, 5) # sample from x with size 1
}
randMat[i, ] = sample(x, 5) # sample from x with size 1
randMat # randomly populated
## or the same with ine loop
for(i in 1:5){
randMat[i, ] = sample(x, 5) # sample from x with size 1
}
randMat # randomly populated
## or the same with ine loop
for(i in 1:5){
randMat[i, ] = sample(x, 5) # sample from x with size 1
}
randMat # randomly populated
vec <- seq(1, 10, by = 1) # my vector of sample values
x <- c(1, 2, 67, 34, 56, 12, 5, 5, 3, 25, 1)
x <- c(1, 2, 67, 34, 56, 12, 5, 5, 3, 25, 1)
mergesort(x)
a <- mergesort(x[1:q])
if((ai <= length(a) && a[ai] < b[bi]) || bi > length(b)) {
r[j] <- a[ai]
ai <- ai + 1
} else {
r[j] <- b[bi]
bi <- bi + 1
}
merge <- function(a, b) {
r <- numeric(length(a) + length(b))
ai <- 1; bi <- 1; j <- 1;
for(j in 1:length(r)) {
if((ai <= length(a) && a[ai] < b[bi]) || bi > length(b)) {
r[j] <- a[ai]
ai <- ai + 1
} else {
r[j] <- b[bi]
bi <- bi + 1
}
}
r
}
mergesort <- function(x) {
if(length(x) > 1) {
q <- ceiling(length(x) / 2)
a <- mergesort(x[1:q])
b <- mergesort(x[(q + 1):length(A)])
merge(a, b)
} else {
x
}
}
x <- c(1, 2, 67, 34, 56, 12, 5, 5, 3, 25, 1)
mergesort(x)
mergesort <- function(x) {
if(length(x) > 1) {
q <- ceiling(length(x) / 2)
a <- mergesort(x[1:q])
b <- mergesort(x[(q + 1):length(x)])
merge(a, b)
} else {
x
}
}
x <- c(1, 2, 67, 34, 56, 12, 5, 5, 3, 25, 1)
mergesort(x)
x <- x2 <- runif(n = 50, min = 1, max = 150) # just a random vector
x <- runif(n = 50, min = 1, max = 150) # just a random vector
mergesort(x)
merge <- function(a, b) {
r <- numeric(length(a) + length(b))
ai <- 1; bi <- 1; j <- 1;
for(j in 1:length(r)) {
if((ai <= length(a) && a[ai] < b[bi]) || bi > length(b)) {
r[j] <- a[ai]
ai <- ai + 1
} else {
r[j] <- b[bi]
bi <- bi + 1
}
}
r
}
mergesort <- function(x) {
if(length(x) > 1) {
q <- ceiling(length(x) / 2)
a <- mergesort(x[1:q])
b <- mergesort(x[(q + 1):length(x)])
merge(a, b)
} else {
x
}
}
randMat <- matrix(data = NA, nrow = 5, ncol = 5) # empty matrix
## with two loops
for(j in 1:5){
for(i in 1:5){
randMat[i, j] = sample(1:10, 1) # sample from 1 to 10 with size 1
}
}
## or the same with one loop
for(i in 1:5){
randMat[i, ] = sample(1:10, 5) # sample from 1 to 10 with size 5
}
randMat # randomly populated
## or the same with one loop
for(i in 1:5){
randMat[i, ] = sample(1:10, 5) # sample from 1 to 10 with size 5
}
randMat # randomly populated
## or the same with one loop
for(i in 1:5){
randMat[i, ] = sample(1:10, 5) # sample from 1 to 10 with size 5
}
randMat # randomly populated
x <- sample(1:200, 20, replace = TRUE) # just a random vector
mergesort(x)
merge <- function(a, b) {
r <- numeric(length(a) + length(b))
ai <- 1; bi <- 1; j <- 1;
for(j in 1:length(r)) {
if((ai <= length(a) && a[ai] < b[bi]) || bi > length(b)) {
r[j] <- a[ai]
ai <- ai + 1
} else {
r[j] <- b[bi]
bi <- bi + 1
}
}
r
}
mergesort <- function(x) {
if(length(x) > 1) {
q <- ceiling(length(x) / 2)
a <- mergesort(x[1:q])
b <- mergesort(x[(q + 1):length(x)])
merge(a, b)
} else {
x
}
}
x <- sample(1:200, 20, replace = TRUE) # just a random vector
mergesort(x)
?sample
x <- sample(1:200, 20, replace = TRUE) # just a random vector
mergesort(x)
x <- sample(1:200, 20, replace = TRUE) # just a random vector
mergesort(x)
## This is the main function that follows the merge sort algorithm
mergesort <- function(x) {
if(length(x) > 1) {
c <- ceiling(length(x) / 2)
a <- mergesort(x[1:q])
b <- mergesort(x[(c + 1):length(x)])
merge(a, b)
} else {
x
}
}
x <- sample(1:200, 20, replace = TRUE) # just a random vector
mergesort(x)
## This is the main function that follows the merge sort algorithm
mergesort <- function(x) {
if(length(x) > 1) {
c <- ceiling(length(x) / 2)
a <- mergesort(x[1:c])
b <- mergesort(x[(c + 1):length(x)])
merge(a, b)
} else {
x
}
}
x <- sample(1:200, 20, replace = TRUE) # just a random vector
mergesort(x)
x <- sample(-200:200, 20, replace = TRUE) # just a random vector
mergesort(x)
## This is a suplementary function that performs the merging operation
merge <- function(a, b) {
result <- numeric(length(a) + length(b))
ai <- 1; bi <- 1; j <- 1;
for(j in 1:length(result)) {
if((ai <= length(a) && a[ai] < b[bi]) || bi > length(b)) {
result[j] <- a[ai]
ai <- ai + 1
} else {
result[j] <- b[bi]
bi <- bi + 1
}
}
r
}
## This is the main function that follows the merge sort's divide and conquer pattern
mergesort <- function(x) {
if(length(x) > 1) {
c <- ceiling(length(x) / 2)
a <- mergesort(x[1:c])
b <- mergesort(x[(c + 1):length(x)])
merge(a, b)
} else {
x
}
}
x <- sample(-200:200, 20, replace = TRUE) # just a random vector ranging from -200 to 200
mergesort(x)
## This is a suplementary function that performs the merging operation
merge <- function(a, b) {
result <- numeric(length(a) + length(b))
ai <- 1; bi <- 1; j <- 1;
for(j in 1:length(result)) {
if((ai <= length(a) && a[ai] < b[bi]) || bi > length(b)) {
result[j] <- a[ai]
ai <- ai + 1
} else {
result[j] <- b[bi]
bi <- bi + 1
}
}
result
}
## This is the main function that follows the merge sort's divide and conquer pattern
mergesort <- function(x) {
if(length(x) > 1) {
c <- ceiling(length(x) / 2)
a <- mergesort(x[1:c])
b <- mergesort(x[(c + 1):length(x)])
merge(a, b)
} else {
x
}
}
x <- sample(-200:200, 20, replace = TRUE) # just a random vector ranging from -200 to 200
mergesort(x)
exams <- read.csv("Exams.csv")
str(exams)
View(exams)
mergesort(x) ## sorting the vector
str(exams)
?reshape
reshape(exams, idvar = Person, timevar = Exam, direction = "wide")
reshape(exams, idvar = "Person", timevar = "Exam", direction = "wide")
exams <- reshape(exams, idvar = "Person", timevar = "Exam", direction = "wide")
exams <- read.csv("Exams.csv")
exams <- reshape(exams, idvar = "Person", timevar = "Exam", direction = "wide")
exams <- read.csv("Exams.csv")
str(exams)
exams
exams <- reshape(exams, idvar = "Person", timevar = "Exam", direction = "wide")
exams
a <- c(1:100, 200:300) # creating the vector a
length(a) # length of vector a
a
a <- c(1:100, 200:300) # creating the vector a
a
length(a) # length of vector a
a <- c(1:5, 'A', 'B', 'C', TRUE)
a
typeof(a)
even <- seq(2, 50, by=2) # used increment of 2 to get even numbers starting from 2
even
evenM1 <- matrix(even, nrow = 5, ncol = 5, byrow = FALSE) # by column
evenM1
evenM2 <- matrix(even, nrow = 5, ncol = 5, byrow = TRUE) # by row
evenM2
class(evenM1) # matrix
class(evenM2) # matrix
evenM2[3, 4] # row=3, col=4
diag(evenM2) <- 0
evenM2 # diagonal elements are 0
data("nba2009_2016")
nba <- nba2009_2016
head(nba)
str(nba)
sapply(nba, class)
nba_matches <- nba[, c(4, 5, 7, 8)]
nba_matches <- nba[, c("home.TEAM_NAME", "home.PTS", "away.TEAM_NAME", "away.PTS")]
nba_matches # same results for both
head(nba_matches) # same results for both
nba_1 <- subset(nba, abs(home.PTS - away.PTS) >= 5 )
nba_1 # games with min difference of 5 points
divisors <- function(x){
##  vector of potential divisors
y <- seq_len(x)
##  If the remainder is 0 => the number is a divisor of x
y[ x%%y == 0 ]
}
divisors(33) # test on 33
randMat <- matrix(data = NA, nrow = 5, ncol = 5) # empty matrix
## with two loops
for(j in 1:5){
for(i in 1:5){
randMat[i, j] = sample(1:10, 1) # sample from 1 to 10 with size 1
}
}
## or the same with one loop
for(i in 1:5){
randMat[i, ] = sample(1:10, 5) # sample from 1 to 10 with size 5
}
randMat # randomly populated
## or the same with one loop
for(i in 1:5){
randMat[i, ] = sample(1:10, 5) # sample from 1 to 10 with size 5
}
randMat # randomly populated
## or the same with one loop
for(i in 1:5){
randMat[i, ] = sample(1:10, 5) # sample from 1 to 10 with size 5
}
randMat # randomly populated
## This is a suplementary function that performs the merging operation
merge <- function(a, b) {
result <- numeric(length(a) + length(b))
ai <- 1; bi <- 1; j <- 1;
for(j in 1:length(result)) {
if((ai <= length(a) && a[ai] < b[bi]) || bi > length(b)) {
result[j] <- a[ai]
ai <- ai + 1
} else {
result[j] <- b[bi]
bi <- bi + 1
}
}
result
}
## This is the main function that follows the merge sort's divide and conquer pattern
mergesort <- function(x) {
if(length(x) > 1) {
c <- ceiling(length(x) / 2)
a <- mergesort(x[1:c])
b <- mergesort(x[(c + 1):length(x)])
merge(a, b)
} else {
x
}
}
x <- sample(-200:200, 20, replace = TRUE) # just a random vector ranging from -200 to 200
mergesort(x) ## sorting the vector
x <- sample(-200:200, 20, replace = TRUE) # just a random vector ranging from -200 to 200
mergesort(x) ## sorting the vector
exams <- read.csv("Exams.csv")
str(exams)
exams <- reshape(exams, idvar = "Person", timevar = "Exam", direction = "wide")
exams
